#!/usr/bin/env python3

import os
import sys
import json
import argparse
import shutil
import subprocess
import time
from pathlib import Path
import importlib.util
from datetime import datetime
from urllib.parse import urlparse
import tempfile

# Load compiler from ~/.roelang/
def load_compiler():
    # First try to load the new modular compiler
    compiler_module_path = Path.home() / ".roelang" / "compiler"
    if compiler_module_path.exists() and (compiler_module_path / "__init__.py").exists():
        # Add the parent directory to sys.path so we can import the module
        sys.path.insert(0, str(Path.home() / ".roelang"))
        try:
            from compiler import compiler
            return compiler
        except ImportError:
            pass
    
    # Fallback to standalone compiler
    compiler_path = Path.home() / ".roelang" / "compiler.py"
    if not compiler_path.exists():
        print("‚ùå Error: compiler not found in ~/.roelang/")
        exit(1)

    spec = importlib.util.spec_from_file_location("compiler", str(compiler_path))
    compiler = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(compiler)
    return compiler

# Load config from roeconfig.json if available
def load_config(project_root=None):
    default_config = {"src": "src", "build": "build", "target": "wasm", "framework": "plain"}
    if project_root is None:
        config_path = Path.cwd() / "roeconfig.json"
    else:
        config_path = project_root / "roeconfig.json"
    
    if config_path.exists():
        try:
            with open(config_path) as f:
                config = json.load(f)
                return {
                    "src": config.get("src", "src"),
                    "build": config.get("build", "build"),
                    "target": config.get("target", "wasm"),
                    "framework": config.get("framework", "plain"),
                    "package": config.get("package"),
                    "database": config.get("database")
                }
        except Exception as e:
            print(f"‚ùå Error reading roeconfig.json: {e}")
            exit(1)
    return default_config

# Initialize a Roelang project
def init_project(name=None, author=None, target=None, framework=None):
    # If name is provided, create a directory for the project
    if name:
        project_root = Path.cwd() / name
        
        # Check if directory already exists
        if project_root.exists():
            if project_root.is_dir():
                if any(project_root.iterdir()):
                    print(f"‚ùå Error: Directory '{name}' already exists and is not empty")
                    print(f"üìÅ Directory: {project_root}")
                    print("üí° Choose a different project name or remove the existing directory")
                    exit(1)
            else:
                print(f"‚ùå Error: A file named '{name}' already exists")
                print(f"üìÅ Location: {project_root}")
                print("üí° Choose a different project name")
                exit(1)
        
        # Create the project directory
        project_root.mkdir(parents=True, exist_ok=True)
        print(f"üìÅ Created project directory: {name}/")
    else:
        # Use current directory
        project_root = Path.cwd()
        
        # Check if directory is not empty
        if any(project_root.iterdir()):
            config_path = project_root / "roeconfig.json"
            if config_path.exists():
                print("‚ùå Error: This directory already contains a Roelang project")
                print(f"üìÅ Current directory: {project_root}")
                print("üí° Use a new empty directory to create a different project")
            else:
                print("‚ùå Error: Directory is not empty")
                print(f"üìÅ Current directory: {project_root}")
                print("üí° 'roe init' must be run in an empty directory or provide a project name")
            exit(1)
    
    src_dir = project_root / "src"
    build_dir = project_root / "build"
    modules_dir = project_root / "modules"
    config_path = project_root / "roeconfig.json"

    # Create directories
    src_dir.mkdir(exist_ok=True)
    build_dir.mkdir(exist_ok=True)
    modules_dir.mkdir(exist_ok=True)

    # Initialize config_data (always available)
    config_data = {
        "src": "src",
        "build": "build",
        "dist": "dist",
        "modules": "modules",
        "main": "src/main.roe",
        "target": target or "wasm"
    }
    
    # Validate framework-target compatibility
    if framework:
        valid_frameworks = {
            "java": ["spring"],
            "python": ["fastapi"],
            "go": ["fiber"],
            "node": ["fastify"],
            "wasm": [],
            "html": [],
            "mobile": []
        }
        
        target_key = target or "wasm"
        if target_key in valid_frameworks:
            if framework != "plain" and framework not in valid_frameworks[target_key]:
                print(f"‚ùå Error: Framework '{framework}' is not compatible with target '{target_key}'")
                if valid_frameworks[target_key]:
                    print(f"üí° Valid frameworks for {target_key}: {', '.join(valid_frameworks[target_key])}")
                else:
                    print(f"üí° Target '{target_key}' does not support frameworks")
                exit(1)
        
        # Add framework if specified and applicable (ignore for targets that don't support frameworks)
        if framework != "plain" and target_key in ["java", "python", "go", "node"]:
            config_data["framework"] = framework
        
    # Add package name for Java Spring projects
    if target == "java" and framework == "spring":
        if name:
            # Convert project name to Java package name format
            package_name = "com.example." + name.lower().replace("-", "").replace("_", "")
        else:
            package_name = "com.example.app"
        config_data["package"] = package_name
        config_data["database"] = "postgresql"  # Default database for Spring

    # Create roeconfig.json
    if not config_path.exists():
        with open(config_path, "w") as f:
            json.dump(config_data, f, indent=2)
        print("‚úÖ Created roeconfig.json")
    else:
        # If config exists, load it to preserve existing values
        with open(config_path) as f:
            existing_config = json.load(f)
            # Use existing config but allow override of target/framework from command line
            for key in ["target", "framework", "package", "database"]:
                if key in config_data:
                    existing_config[key] = config_data[key]
            config_data = existing_config


    # Create a sample main.roe file
    main_file = src_dir / "main.roe"
    if not main_file.exists():
        # Generate target-specific sample content  
        project_name = name or project_root.name
        
        if target == "java" and framework == "spring":
            main_content = f'''@target java
@framework spring
@package {config_data.get("package", "com.example.app")}

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "html":
            main_content = f'''@target html

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "mobile":
            main_content = f'''@target mobile

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "python":
            main_content = f'''@target python

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "go":
            main_content = f'''@target go

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "node":
            main_content = f'''@target node

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        else:
            # Default WASM/generic content
            main_content = f'''set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        with open(main_file, "w") as f:
            f.write(main_content)
        print("‚úÖ Created src/main.roe")

    print("‚úÖ Initialized Roelang project successfully!")
    print(f"üìÅ Project name: {name or project_root.name}")
    if author:
        print(f"üë§ Author: {author}")
    # Show framework only for targets that support it
    framework_targets = ["java", "python", "go", "node"] 
    show_framework = framework and framework != "plain" and (target or "wasm") in framework_targets
    print(f"üéØ Target: {target or 'wasm'}" + (f" with {framework} framework" if show_framework else ""))
    print("\nüìÇ Directory structure:")
    print("  src/         - Source code (.roe files)")
    print("  modules/     - Downloaded packages")
    print("  build/       - Compiled files")
    print("  dist/        - Distribution packages")
    print("\nüöÄ Next steps:")
    if name:  # If a project directory was created
        print(f"  cd {name}/              - Navigate to project directory")
        print("  roe run src/main.roe     - Run the sample")
        print("  roe build               - Build project")
    else:  # If initialized in current directory
        print("  roe run src/main.roe     - Run the sample")
        print("  roe build               - Build project")

# Package management functions
def install_package(package_name, is_dev=False):
    """Install a package from a repository."""
    project_root = find_project_root()
    modules_dir = project_root / "modules"
    package_path = project_root / "package.json"
    
    # Create modules directory if it doesn't exist
    modules_dir.mkdir(exist_ok=True)
    
    # Load package.json
    if not package_path.exists():
        print("‚ùå Error: package.json not found. Run 'roe init' first.")
        exit(1)
    
    with open(package_path) as f:
        package_data = json.load(f)
    
    print(f"üì¶ Installing {package_name}...")
    
    # For now, simulate package installation from a registry
    # In a real implementation, this would:
    # 1. Resolve package name to repository URL
    # 2. Download from git/registry
    # 3. Extract .roe files to modules directory
    
    package_dir = modules_dir / package_name
    
    # Simulate package download (create example package structure)
    if package_name == "math-utils":
        package_dir.mkdir(exist_ok=True)
        
        # Create example DSL files
        math_roe = package_dir / "math.roe"
        with open(math_roe, "w") as f:
            f.write('''# Math utilities package
module MathUtils
    action add with a which is int and b which is int returns int
        return a + b
    end
    
    action multiply with x which is decimal and y which is decimal returns decimal
        return x * y
    end
    
    action power with base which is int and exp which is int returns int
        set result which is int to 1
        set i which is int to 0
        while i < exp
            set result to result * base
            set i to i + 1
        end
        return result
    end
end
''')
        
        package_info = package_dir / "package.json"
        with open(package_info, "w") as f:
            json.dump({
                "name": "math-utils",
                "version": "1.0.0",
                "description": "Mathematical utility functions for Roelang",
                "main": "math.roe",
                "files": ["math.roe"]
            }, f, indent=2)
        
        print(f"‚úÖ Downloaded math-utils to modules/{package_name}")
    elif package_name == "string-utils":
        package_dir.mkdir(exist_ok=True)
        
        string_roe = package_dir / "strings.roe"
        with open(string_roe, "w") as f:
            f.write('''# String utilities package
module StringUtils
    action uppercase with text which is text returns text
        # Placeholder for uppercase functionality
        return text + " (UPPER)"
    end
    
    action concat_with_separator with items which are list of text and sep which is text returns text
        # Placeholder for join functionality
        return "Joined: " + items[0] + sep + items[1]
    end
end
''')
        
        print(f"‚úÖ Downloaded string-utils to modules/{package_name}")
    else:
        print(f"‚ùå Package '{package_name}' not found in registry")
        print("üí° Available packages: math-utils, string-utils")
        exit(1)
    
    # Update package.json dependencies
    dep_key = "devDependencies" if is_dev else "dependencies"
    if dep_key not in package_data:
        package_data[dep_key] = {}
    
    package_data[dep_key][package_name] = "^1.0.0"
    
    with open(package_path, "w") as f:
        json.dump(package_data, f, indent=2)
    
    print(f"‚úÖ Added {package_name} to {dep_key}")
    print(f"üí° Use: include \"{package_name}/{package_name.replace('-', '_')}.roe\"")

def clean_build(clean_all=False):
    """Clean build directory and optionally dist directory."""
    project_root = find_project_root()
    config = load_config(project_root)
    
    build_dir = project_root / config.get("build", "build")
    dist_dir = project_root / config.get("dist", "dist")
    
    cleaned_dirs = []
    
    # Clean build directory
    if build_dir.exists():
        shutil.rmtree(build_dir)
        cleaned_dirs.append(str(build_dir.name))
        print(f"üßπ Cleaned {build_dir}")
    else:
        print(f"‚ÑπÔ∏è  Build directory {build_dir} doesn't exist")
    
    # Clean dist directory if --all flag is used
    if clean_all:
        if dist_dir.exists():
            shutil.rmtree(dist_dir)
            cleaned_dirs.append(str(dist_dir.name))
            print(f"üßπ Cleaned {dist_dir}")
        else:
            print(f"‚ÑπÔ∏è  Dist directory {dist_dir} doesn't exist")
    
    if cleaned_dirs:
        print(f"‚úÖ Cleaned {len(cleaned_dirs)} director{'y' if len(cleaned_dirs) == 1 else 'ies'}: {', '.join(cleaned_dirs)}")
    else:
        print("‚ÑπÔ∏è  Nothing to clean")

def show_version():
    """Show version information."""
    print("Roe Lang Compiler & Runtime")
    print("Version: 1.0.0")
    print("Build: 2024-08-06")
    print("")
    print("Components:")
    print("  - Compiler: Python-based DSL to WebAssembly")
    print("  - Runtime: Node.js WebAssembly executor")
    print("  - Package Manager: Module-based dependency system")

def show_help():
    """Show comprehensive help information."""
    print("Roe Lang - Domain Specific Language Compiler")
    print("")
    print("USAGE:")
    print("    roe [COMMAND] [OPTIONS]")
    print("")
    print("COMMANDS:")
    print("    init [name]             Initialize new Roelang project")
    print("    compile <file>          Compile .roe file to target language")
    print("    run <file>              Compile and run .roe file")
    print("    build                   Build entire project")
    print("    clean                   Clean build directory")
    print("    install [package]       Install package dependencies")
    print("")
    print("INIT OPTIONS:")
    print("    name                    Project name (creates directory if specified)")
    print("    --author <author>       Set project author")
    print("    --target <target>       Set compilation target (wasm|python|java|go|node|html|mobile)")
    print("    --framework <fw>        Set framework (spring|fastapi|fiber|fastify)")
    print("")
    print("INSTALL OPTIONS:")
    print("    --dev                   Install as development dependency")
    print("")
    print("BUILD OPTIONS:")
    print("    --clean                 Clean build directory first")
    print("    --release               Build for production (optimized)")
    print("")
    print("CLEAN OPTIONS:")
    print("    --all                   Also clean dist directory")
    print("")
    print("COMPILE OPTIONS:")
    print("    --format <fmt>          Output format (wat|wasm) [default: wasm]")
    print("    --output <path>         Output file path")
    print("    --watch                 Watch for file changes")
    print("")
    print("RUN OPTIONS:")
    print("    --watch                 Watch and rerun on changes")
    print("")
    print("GLOBAL OPTIONS:")
    print("    -h, --help              Show this help message")
    print("    --version               Show version information")
    print("")
    print("EXAMPLES:")
    print("    roe init my-app --author \"John Doe\"")
    print("    roe init my-api --target java --framework spring")
    print("    roe init api-server --target python --framework fastapi")
    print("    roe init web-server --target go --framework fiber") 
    print("    roe init node-api --target node --framework fastify")
    print("    roe init web-app --target html")
    print("    roe init my-mobile-app --target mobile")
    print("    roe init --target python                      # Initialize in current directory")
    print("    roe install math-utils")
    print("    roe install dev-tools --dev")
    print("    roe compile src/main.roe --target java")
    print("    roe compile src/main.roe --format wasm --output dist/main.wasm")
    print("    roe run src/main.roe --watch")
    print("    roe build --clean --release")
    print("    roe clean")
    print("    roe clean --all")

# Load compiler
compiler = load_compiler()

# Find project root by looking for roeconfig.json
def find_project_root():
    """Find the project root by looking for roeconfig.json up to 10 levels."""
    current = Path.cwd()
    original = current
    root = current.root
    max_depth = 10  # Look up to 10 levels
    depth = 0
    
    # Look for roeconfig.json in current and parent directories (up to max_depth)
    while current != Path(root) and depth < max_depth:
        if (current / "roeconfig.json").exists():
            return current
        
        parent = current.parent
        if parent == current:
            break
        current = parent
        depth += 1
    
    # No roeconfig.json found - require user to create one
    print(f"‚ùå Error: No roeconfig.json found (searched up {depth} directories)")
    print(f"üìÇ Current directory: {original}")
    print(f"\nüí° To create a Roelang project, run: roe init")
    print(f"   This will create roeconfig.json in the current directory")
    exit(1)

# Build distribution package
def build_distribution(project_root, clean=False, release=False):
    """Build distribution package with manifest.json and .wasm files."""
    import shutil
    import subprocess
    from glob import glob
    
    # Load config
    config_path = project_root / "roeconfig.json"
    if not config_path.exists():
        print("‚ùå Error: roeconfig.json not found")
        exit(1)
    
    with open(config_path) as f:
        config = json.load(f)
    
    # Get config values with defaults
    src_pattern = config.get("src", ".")
    build_dir = project_root / config.get("build", "build")
    dist_dir = project_root / config.get("dist", "dist")
    main_file = config.get("main", "src/main.roe")
    target = config.get("target", "wasm")
    framework = config.get("framework", "plain")
    
    print(f"üì¶ Building distribution package...")
    print(f"üéØ Target: {target}" + (f" ({framework})" if framework != "plain" else ""))
    if release:
        print("üöÄ Release build (optimized)")
    if clean:
        print("üßπ Cleaning build directory")
    print(f"üìÇ Source pattern: {src_pattern}")
    print(f"üìÇ Build directory: {build_dir}")
    print(f"üìÇ Dist directory: {dist_dir}")
    print(f"üéØ Main entry: {main_file}")
    
    # Clean build directory if requested
    if clean and build_dir.exists():
        shutil.rmtree(build_dir)
        print(f"üßπ Cleaned {build_dir}")
    
    # Find all .roe files in the project
    if src_pattern == ".":
        search_root = project_root
    else:
        search_root = project_root / src_pattern
    
    roe_files = []
    if search_root.exists():
        roe_files = list(search_root.rglob("*.roe"))
    
    if not roe_files:
        print(f"‚ö†Ô∏è  Warning: No .roe files found in {search_root}")
        print("üí° Add some .roe files to your project first")
    else:
        print(f"üîç Found {len(roe_files)} .roe files to compile:")
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            print(f"   {rel_path}")
        
        # Compile all .roe files
        print(f"üî® Compiling {len(roe_files)} files...")
        compiled_count = 0
        failed_count = 0
        
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            try:
                # Use subprocess to call roe compile for each file
                result = subprocess.run([
                    sys.executable, str(Path.home() / ".roelang" / "bin" / "roe"), 
                    "compile", str(rel_path)
                ], cwd=project_root, capture_output=True, text=True)
                
                if result.returncode == 0:
                    compiled_count += 1
                    print(f"   ‚úÖ {rel_path}")
                else:
                    failed_count += 1
                    print(f"   ‚ùå {rel_path}: {result.stderr.strip()}")
            except Exception as e:
                failed_count += 1
                print(f"   ‚ùå {rel_path}: {e}")
        
        print(f"üìä Compilation complete: {compiled_count} succeeded, {failed_count} failed")
        
        if failed_count > 0:
            print("‚ö†Ô∏è  Some files failed to compile. Distribution will only include successful compilations.")
    
    # Ensure build directory exists (might be created by compilation)
    build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create/clean dist directory
    if dist_dir.exists():
        shutil.rmtree(dist_dir)
    dist_dir.mkdir(parents=True, exist_ok=True)
    
    # Handle different target types
    copied_files = []
    main_entry = None
    
    if target == "java" and framework == "spring":
        # Handle Java Spring Boot projects
        print("üì± Packaging Spring Boot projects...")
        
        # Find all Spring Boot project directories in build
        for project_dir in build_dir.iterdir():
            if project_dir.is_dir() and (project_dir / "pom.xml").exists():
                relative_path = project_dir.relative_to(build_dir)
                
                # Copy entire Spring Boot project to dist
                dest_dir = dist_dir / relative_path
                shutil.copytree(project_dir, dest_dir, dirs_exist_ok=True)
                copied_files.append(str(relative_path))
                print(f"üìã Copied Spring Boot project: {relative_path}")
                
                # Set main entry to first project found
                if main_entry is None:
                    main_entry = str(relative_path)
        
        if not copied_files:
            print("‚ö†Ô∏è  Warning: No Spring Boot projects found in build directory")
            print("üí° Run 'roe compile' on your .roe files first")
    
    elif target == "mobile":
        # Handle mobile projects
        print("üì± Packaging mobile projects...")
        
        # Look for android/ios directories
        for mobile_dir in ["android", "ios"]:
            mobile_path = build_dir / mobile_dir
            if mobile_path.exists():
                dest_dir = dist_dir / mobile_dir
                shutil.copytree(mobile_path, dest_dir, dirs_exist_ok=True)
                copied_files.append(mobile_dir)
                print(f"üìã Copied mobile project: {mobile_dir}")
        
        if not copied_files:
            print("‚ö†Ô∏è  Warning: No mobile projects found in build directory")
            print("üí° Run 'roe compile' on your .roe files first")
    
    else:
        # Handle WASM and other single-file targets
        target_extensions = {
            "wasm": "*.wasm",
            "python": "*.py", 
            "java": "*.java",
            "go": "*.go",
            "node": "*.js",
            "html": "*.html"
        }
        
        pattern = target_extensions.get(target, "*.wasm")
        print(f"üì¶ Looking for {pattern} files...")
        
        for target_file in build_dir.rglob(pattern):
            relative_path = target_file.relative_to(build_dir)
            copied_files.append(str(relative_path))
            
            # Copy to dist with same structure
            dest_file = dist_dir / relative_path
            dest_file.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(target_file, dest_file)
            print(f"üìã Copied: {relative_path}")
        
        if not copied_files:
            print(f"‚ö†Ô∏è  Warning: No {pattern} files found in build directory")
            print("üí° Run 'roe compile' or 'roe run' on some files first")
        
        # Set main entry for single-file targets
        if main_file and copied_files:
            main_stem = Path(main_file).stem
            for file_path in copied_files:
                if Path(file_path).stem == main_stem:
                    main_entry = file_path
                    break
            # Fallback to first file
            if main_entry is None and copied_files:
                main_entry = copied_files[0]
    
    # Generate manifest.json
    manifest = {
        "name": project_root.name,
        "version": "1.0.0",
        "description": config.get("description", f"Roelang project: {project_root.name}"),
        "target": target,
        "framework": framework if framework != "plain" else None,
        "main": main_entry,
        "files": copied_files,
        "build_time": __import__('datetime').datetime.now().isoformat(),
        "roelang_version": "1.0.0"
    }
    
    manifest_path = dist_dir / "manifest.json"
    with open(manifest_path, "w") as f:
        json.dump(manifest, f, indent=2)
    
    print(f"üìÑ Created manifest.json")
    print(f"‚úÖ Distribution built successfully!")
    print(f"üì¶ {len(copied_files)} files copied to {dist_dir}")
    if main_entry:
        print(f"üéØ Main entry: {main_entry}")

# Command line parsing with argparse
def main():
    parser = argparse.ArgumentParser(
        prog='roe',
        description='Roe Lang - Domain Specific Language Compiler',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Global flags
    parser.add_argument('--version', action='store_true', help='Show version information')
    
    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize new Roelang project')
    init_parser.add_argument('project_name', nargs='?', help='Project name (creates directory if specified)')
    init_parser.add_argument('--name', help='Project name (deprecated, use positional argument)')
    init_parser.add_argument('--author', help='Project author')
    init_parser.add_argument('--target', choices=['wasm', 'python', 'java', 'go', 'node', 'html', 'mobile'], help='Compilation target')
    init_parser.add_argument('--framework', choices=['plain', 'spring', 'fastapi', 'fiber', 'fastify'], help='Framework to use with target')
    
    # Install command
    install_parser = subparsers.add_parser('install', help='Install package dependencies')
    install_parser.add_argument('package', nargs='?', help='Package name to install')
    install_parser.add_argument('--dev', action='store_true', help='Install as development dependency')
    
    # Build command
    build_parser = subparsers.add_parser('build', help='Build entire project')
    build_parser.add_argument('--clean', action='store_true', help='Clean build directory first')
    build_parser.add_argument('--release', action='store_true', help='Build for production')
    
    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Clean build directory')
    clean_parser.add_argument('--all', action='store_true', help='Also clean dist directory')
    
    # Compile command
    compile_parser = subparsers.add_parser('compile', help='Compile .roe file to specified target')
    compile_parser.add_argument('file', help='Source file to compile')
    compile_parser.add_argument('--format', choices=['wat', 'wasm'], help='Legacy output format (wat/wasm)')
    compile_parser.add_argument('--target', choices=['wasm', 'python', 'java', 'go', 'node', 'html', 'kotlin', 'swift', 'bytecode', 'mobile'], help='Compilation target (overrides roeconfig.json)')
    compile_parser.add_argument('--output', help='Output file path')
    compile_parser.add_argument('--watch', action='store_true', help='Watch for file changes')
    
    # Run command
    run_parser = subparsers.add_parser('run', help='Compile and run .roe file')
    run_parser.add_argument('file', help='Source file to run')
    run_parser.add_argument('--watch', action='store_true', help='Watch and rerun on changes')
    
    # Handle legacy usage patterns
    if len(sys.argv) == 1 or (len(sys.argv) == 2 and sys.argv[1] in ['-h', '--help']):
        show_help()
        return
    
    # Handle version flag
    if len(sys.argv) == 2 and sys.argv[1] == '--version':
        show_version()
        return
    
    # Handle legacy command patterns
    if len(sys.argv) >= 2 and sys.argv[1] not in ['init', 'install', 'build', 'clean', 'compile', 'run', '--version', '-h', '--help']:
        if sys.argv[1] in ['-h', '--help']:
            show_help()
            return
        else:
            # Legacy usage - try to infer command
            print("‚ùå Unknown command. Use 'roe --help' for usage information.")
            return
    
    args = parser.parse_args()
    
    # Handle version flag
    if args.version:
        show_version()
        return
    
    # Handle commands
    if args.command == 'init':
        # Use positional argument if provided, otherwise fall back to --name flag
        project_name = args.project_name or args.name
        init_project(project_name, args.author, args.target, args.framework)
        return
    
    elif args.command == 'install':
        if args.package:
            install_package(args.package, args.dev)
        else:
            # Install all dependencies from package.json
            project_root = find_project_root()
            package_path = project_root / "package.json"
            if package_path.exists():
                with open(package_path) as f:
                    package_data = json.load(f)
                
                dependencies = package_data.get('dependencies', {})
                dev_dependencies = package_data.get('devDependencies', {})
                
                print("üì¶ Installing dependencies...")
                for pkg in dependencies:
                    install_package(pkg, False)
                for pkg in dev_dependencies:
                    install_package(pkg, True)
            else:
                print("‚ùå Error: package.json not found. Run 'roe init' first.")
        return
    
    elif args.command == 'build':
        project_root = find_project_root()
        config = load_config(project_root)
        
        # Check if this is a mobile project
        if config.get('target') == 'mobile':
            build_mobile_project(project_root, args.clean, args.release)
        else:
            build_distribution(project_root, args.clean, args.release)
        return
    
    elif args.command == 'clean':
        clean_build(args.all)
        return
    
    elif args.command == 'compile':
        # Handle format vs target arguments
        output_format = args.format or 'wasm'
        target_override = args.target
        compile_file(args.file, output_format, args.output, args.watch, target_override)
        return
    
    elif args.command == 'run':
        run_file(args.file, args.watch)
        return
    
    else:
        show_help()

def compile_file(roe_filename, output_format='wasm', output_path=None, watch=False, target_override=None):
    """Compile a single .roe file."""
    def do_compile():
        # Determine project root
        project_root = find_project_root()
        config = load_config(project_root)
        
        # Resolve paths
        config_build_dir = project_root / config["build"]
        tool_dir = Path.home() / ".roelang"
        
        # Handle file path relative to current working directory
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        # Calculate relative path for build directory structure
        if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
            relative_path = roe_file.relative_to(project_root)
        else:
            relative_path = Path(roe_file.name)
        
        basename = roe_file.stem
        
        # Determine build directory
        build_dir = config_build_dir
        if relative_path.parent != Path("."):
            build_dir = build_dir / relative_path.parent
        
        # Set output files
        if output_path:
            if output_format == 'wat':
                wat_file = Path(output_path)
                wasm_file = wat_file.with_suffix('.wasm')
            else:
                wasm_file = Path(output_path)
                wat_file = wasm_file.with_suffix('.wat')
        else:
            wat_file = build_dir / f"{basename}.wat"
            wasm_file = build_dir / f"{basename}.wasm"
        
        # Validations
        if not roe_file.exists() or not roe_file.suffix == ".roe":
            print(f"‚ùå Error: {roe_file} not found or not a .roe file")
            exit(1)
        
        # Ensure build directory exists
        wat_file.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            # Read source to check for @target metadata
            with open(roe_file, 'r') as f:
                source_content = f.read()
            
            # Determine target language with correct priority:
            # 1. CLI target override (--target)
            # 2. DSL metadata (@target) 
            # 3. Project config target
            # 4. Default wasm
            if target_override:
                target = target_override
            else:
                config_target = config.get("target", "wasm")
                target = compiler.get_target_from_source(source_content, config_target)
            
            # If output_format is specified and not 'wasm', it's likely wat - keep backward compatibility
            if not target_override and output_format == 'wat':
                target = 'wasm'  # WAT is part of WASM target
            
            print(f"üî® Compiling {roe_file} -> {target.upper()}")
            
            # Use new multi-target compiler if available
            if hasattr(compiler, 'compile_file') and hasattr(compiler, 'CompilerError'):
                try:
                    # For mobile targets, don't create individual output paths
                    if target == 'mobile':
                        # Mobile projects handle their own directory structure
                        output_file = compiler.compile_file(str(roe_file), target=target, framework=config.get("framework", "plain"), package=config.get("package"), database=config.get("database"))
                    else:
                        # Calculate output path for build directory if not specified
                        if output_path is None:
                            # Determine the appropriate file extension for the target
                            target_extensions = {
                                'wasm': '.wat',
                                'python': '.py', 
                                'java': '.java',
                                'go': '.go',
                                'node': '.js',
                                'html': '.html',
                                'kotlin': '.kt',
                                'swift': '.swift',
                                'bytecode': '.roebc'
                            }
                            extension = target_extensions.get(target, '.txt')
                            computed_output_path = build_dir / f"{basename}{extension}"
                        else:
                            computed_output_path = Path(output_path)
                        
                        # Ensure build directory exists
                        computed_output_path.parent.mkdir(parents=True, exist_ok=True)
                        
                        output_file = compiler.compile_file(str(roe_file), output_path=str(computed_output_path), target=target, framework=config.get("framework", "plain"), package=config.get("package"), database=config.get("database"))
                    # Handle different types of compilation results
                    if isinstance(output_file, dict) and 'files' in output_file:
                        # Multi-file project (like Spring Boot)
                        project_root = output_file.get('project_root', 'project')
                        num_files = len(output_file.get('files', {}))
                        print(f"‚úÖ Compiled successfully -> {project_root}/ ({num_files} files)")
                    else:
                        # Single file result
                        print(f"‚úÖ Compiled successfully -> {output_file}")
                    
                    # Runtime files are no longer needed - using inline code generation
                    print("‚ÑπÔ∏è  Runtime dependency eliminated - using native language features")
                    
                    # Handle backward compatibility for wasm format
                    if target == 'wasm' and output_format == 'wasm' and isinstance(output_file, str):
                        # For WASM target, also generate .wasm file using wat2wasm
                        if output_file.endswith('.wat'):
                            wasm_output = output_file.replace('.wat', '.wasm')
                            result = subprocess.run(['wat2wasm', output_file, '-o', wasm_output], 
                                                  capture_output=True, text=True)
                            if result.returncode != 0:
                                print(f"‚ùå Error compiling to WASM: {result.stderr}")
                                return False
                            print(f"‚úÖ Also generated -> {wasm_output}")
                    
                    return True
                except Exception as e:
                    print(f"‚ùå Compilation failed: {e}")
                    return False
            else:
                # Fallback to old WAT-based compilation
                print("‚ö†Ô∏è  Using legacy WAT-only compiler")
                if hasattr(compiler, 'compile_file'):
                    compiler.compile_file(str(roe_file), str(wat_file))
                else:
                    compiler.compile_roe_to_wat(roe_file, wat_file)
                
                if output_format == 'wasm':
                    # Compile to .wasm
                    result = subprocess.run(['wat2wasm', str(wat_file), '-o', str(wasm_file)], 
                                          capture_output=True, text=True)
                    if result.returncode != 0:
                        print(f"‚ùå Error compiling to WASM: {result.stderr}")
                        return False
                    print(f"‚úÖ Compiled successfully -> {wasm_file}")
                else:
                    print(f"‚úÖ Compiled successfully -> {wat_file}")
                
                return True
        except Exception as e:
            print(f"‚ùå Compilation failed: {e}")
            return False
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_compile()
                        print(f"üëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_compile()

def run_file(roe_filename, watch=False):
    """Compile and run a .roe file."""
    # Check if this is a mobile project first
    project_root = find_project_root()
    config = load_config(project_root)
    
    if config.get("target") == "mobile":
        # Use mobile-specific run function
        run_mobile_app(roe_filename, watch)
        return
    
    def do_run():
        # Read source to determine the actual target (respecting @target metadata)
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
            
        with open(roe_file, 'r') as f:
            source_content = f.read()
        
        # Use proper target resolution: @target metadata > config > bytecode default
        config_target = config.get("target", "bytecode")  # Default to bytecode for speed
        target = compiler.get_target_from_source(source_content, config_target)
        
        # First compile (pass None as target_override to let compile_file do target resolution)
        success = compile_file(roe_filename, output_format=None, target_override=None)
        if not success:
            return False
        
        # Then run based on target
        if target == "bytecode":
            return run_bytecode_file(roe_filename)
        else:
            return run_wasm_file(roe_filename)
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_run()
                        print(f"\nüëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_run()

def run_bytecode_file(roe_filename):
    """Run a bytecode file using the Rust VM."""
    project_root = find_project_root()
    config = load_config(project_root)
    tool_dir = Path.home() / ".roelang"
    vm_binary = tool_dir / "roevm"
    
    roe_file = Path(roe_filename)
    if not roe_file.is_absolute():
        roe_file = Path.cwd() / roe_filename
    
    # Calculate build path
    config_build_dir = project_root / config["build"]
    if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
        relative_path = roe_file.relative_to(project_root)
    else:
        relative_path = Path(roe_file.name)
    
    basename = roe_file.stem
    build_dir = config_build_dir
    if relative_path.parent != Path("."):
        build_dir = build_dir / relative_path.parent
    
    bytecode_file = build_dir / f"{basename}.roebc"
    
    if not vm_binary.exists():
        print(f"‚ùå Error: Roe VM not found at {vm_binary}")
        print("üí° You may need to build the VM: cargo build --release --manifest-path roevm/Cargo.toml")
        return False
    
    print(f"üöÄ Running {bytecode_file} with Roe VM")
    print("‚îÄ" * 40)
    
    result = subprocess.run([str(vm_binary), 'run', str(bytecode_file)])
    return result.returncode == 0

def run_wasm_file(roe_filename):
    """Run a WASM file using Node.js (legacy)."""
    project_root = find_project_root()
    config = load_config(project_root)
    tool_dir = Path.home() / ".roelang"
    runtime = tool_dir / "run.js"
    
    roe_file = Path(roe_filename)
    if not roe_file.is_absolute():
        roe_file = Path.cwd() / roe_filename
    
    # Calculate build path
    config_build_dir = project_root / config["build"]
    if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
        relative_path = roe_file.relative_to(project_root)
    else:
        relative_path = Path(roe_file.name)
    
    basename = roe_file.stem
    build_dir = config_build_dir
    if relative_path.parent != Path("."):
        build_dir = build_dir / relative_path.parent
    
    wasm_file = build_dir / f"{basename}.wasm"
    
    print(f"üöÄ Running {wasm_file}")
    print("‚îÄ" * 40)
    
    result = subprocess.run(['node', str(runtime), str(wasm_file)])
    return result.returncode == 0


def build_mobile_project(project_root, clean=False, release=False):
    """Build mobile project - development or release."""
    try:
        # Import mobile build system
        sys.path.insert(0, str(Path.home() / ".roelang"))
        from compiler.targets.mobile.build_system import MobileBuildSystem
        
        if clean:
            clean_build(all_dirs=False)
        
        builder = MobileBuildSystem(Path(project_root))
        results = builder.build_mobile_projects(release=release)
        
        if results:
            if release:
                print(f"\nüéâ Release builds completed!")
                for platform, path in results.items():
                    print(f"   üì± {platform.title()}: {path}")
            else:
                print(f"\n‚úÖ Development builds completed!")
        else:
            print(f"\n‚ùå No builds were successful")
            print(f"üí° Check that mobile projects exist in build/ directory")
            exit(1)
            
    except ImportError as e:
        print(f"‚ùå Mobile build system not available: {e}")
        print(f"üí° Make sure the Roelang compiler is properly installed")
        exit(1)
    except Exception as e:
        print(f"‚ùå Mobile build failed: {e}")
        exit(1)


def run_mobile_app(roe_filename, watch=False):
    """Run mobile app with incremental updates."""
    def do_mobile_run():
        # First ensure projects are up to date
        success = compile_file(roe_filename, output_format=None, target_override=None)
        if not success:
            return False
        
        # Then run the mobile app
        try:
            sys.path.insert(0, str(Path.home() / ".roelang"))
            from compiler.targets.mobile.build_system import MobileBuildSystem
            
            project_root = find_project_root()
            builder = MobileBuildSystem(Path(project_root))
            return builder.run_mobile_app()
            
        except ImportError as e:
            print(f"‚ùå Mobile build system not available: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Failed to run mobile app: {e}")
            return False
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_mobile_run()
                        print(f"\nüëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_mobile_run()


if __name__ == "__main__":
    main()

