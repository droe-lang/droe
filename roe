#!/usr/bin/env python3

import os
import sys
import json
from pathlib import Path
import importlib.util

# Load compiler from ~/.roelang/
def load_compiler():
    # First try to load the new modular compiler
    compiler_module_path = Path.home() / ".roelang" / "compiler"
    if compiler_module_path.exists() and (compiler_module_path / "__init__.py").exists():
        # Add the parent directory to sys.path so we can import the module
        sys.path.insert(0, str(Path.home() / ".roelang"))
        try:
            from compiler import compiler
            return compiler
        except ImportError:
            pass
    
    # Fallback to standalone compiler
    compiler_path = Path.home() / ".roelang" / "compiler.py"
    if not compiler_path.exists():
        print("‚ùå Error: compiler not found in ~/.roelang/")
        exit(1)

    spec = importlib.util.spec_from_file_location("compiler", str(compiler_path))
    compiler = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(compiler)
    return compiler

# Load config from roeconfig.json if available
def load_config():
    default_config = {"src": "src", "build": "build"}
    config_path = Path.cwd() / "roeconfig.json"
    if config_path.exists():
        try:
            with open(config_path) as f:
                config = json.load(f)
                return {
                    "src": config.get("src", "src"),
                    "build": config.get("build", "build")
                }
        except Exception as e:
            print(f"‚ùå Error reading roeconfig.json: {e}")
            exit(1)
    return default_config

# Initialize a Roelang project
def init_project():
    project_root = Path.cwd()
    src_dir = project_root / "src"
    build_dir = project_root / "build"
    config_path = project_root / "roeconfig.json"

    if any(project_root.iterdir()) and not config_path.exists():
        confirm = input("‚ö†Ô∏è Current directory is not empty. Continue? (y/N): ")
        if confirm.lower() != "y":
            print("‚ùå Aborted.")
            exit(1)

    src_dir.mkdir(exist_ok=True)
    build_dir.mkdir(exist_ok=True)

    if not config_path.exists():
        config_data = {
            "src": ".",
            "build": "build",
            "dist": "dist",
            "main": "src/main.roe"
        }
        with open(config_path, "w") as f:
            json.dump(config_data, f, indent=2)
        print("‚úÖ Created roeconfig.json")

    print("‚úÖ Initialized empty Roelang project.")
    print("\nNext steps:")
    print("  Add files anywhere in the project")
    print("  roe run filename.roe (supports paths like src/main.roe)")
    print("  Build files will be organized in build/ directory")

# Load compiler
compiler = load_compiler()

# Find project root by looking for roeconfig.json
def find_project_root():
    """Find the project root by looking for roeconfig.json up to 10 levels."""
    current = Path.cwd()
    original = current
    root = current.root
    max_depth = 10  # Look up to 10 levels
    depth = 0
    
    # Look for roeconfig.json in current and parent directories (up to max_depth)
    while current != Path(root) and depth < max_depth:
        if (current / "roeconfig.json").exists():
            return current
        
        parent = current.parent
        if parent == current:
            break
        current = parent
        depth += 1
    
    # No roeconfig.json found - require user to create one
    print(f"‚ùå Error: No roeconfig.json found (searched up {depth} directories)")
    print(f"üìÇ Current directory: {original}")
    print(f"\nüí° To create a Roelang project, run: roe init")
    print(f"   This will create roeconfig.json in the current directory")
    exit(1)

# Build distribution package
def build_distribution(project_root):
    """Build distribution package with manifest.json and .wasm files."""
    import shutil
    import subprocess
    from glob import glob
    
    # Load config
    config_path = project_root / "roeconfig.json"
    if not config_path.exists():
        print("‚ùå Error: roeconfig.json not found")
        exit(1)
    
    with open(config_path) as f:
        config = json.load(f)
    
    # Get config values with defaults
    src_pattern = config.get("src", ".")
    build_dir = project_root / config.get("build", "build")
    dist_dir = project_root / config.get("dist", "dist")
    main_file = config.get("main", "src/main.roe")
    
    print(f"üì¶ Building distribution package...")
    print(f"üìÇ Source pattern: {src_pattern}")
    print(f"üìÇ Build directory: {build_dir}")
    print(f"üìÇ Dist directory: {dist_dir}")
    print(f"üéØ Main entry: {main_file}")
    
    # Find all .roe files in the project
    if src_pattern == ".":
        search_root = project_root
    else:
        search_root = project_root / src_pattern
    
    roe_files = []
    if search_root.exists():
        roe_files = list(search_root.rglob("*.roe"))
    
    if not roe_files:
        print(f"‚ö†Ô∏è  Warning: No .roe files found in {search_root}")
        print("üí° Add some .roe files to your project first")
    else:
        print(f"üîç Found {len(roe_files)} .roe files to compile:")
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            print(f"   {rel_path}")
        
        # Compile all .roe files
        print(f"üî® Compiling {len(roe_files)} files...")
        compiled_count = 0
        failed_count = 0
        
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            try:
                # Use subprocess to call roe compile for each file
                result = subprocess.run([
                    sys.executable, str(Path.home() / ".roelang" / "bin" / "roe"), 
                    "compile", str(rel_path)
                ], cwd=project_root, capture_output=True, text=True)
                
                if result.returncode == 0:
                    compiled_count += 1
                    print(f"   ‚úÖ {rel_path}")
                else:
                    failed_count += 1
                    print(f"   ‚ùå {rel_path}: {result.stderr.strip()}")
            except Exception as e:
                failed_count += 1
                print(f"   ‚ùå {rel_path}: {e}")
        
        print(f"üìä Compilation complete: {compiled_count} succeeded, {failed_count} failed")
        
        if failed_count > 0:
            print("‚ö†Ô∏è  Some files failed to compile. Distribution will only include successful compilations.")
    
    # Ensure build directory exists (might be created by compilation)
    build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create/clean dist directory
    if dist_dir.exists():
        shutil.rmtree(dist_dir)
    dist_dir.mkdir(parents=True, exist_ok=True)
    
    # Find all .wasm files in build directory
    wasm_files = []
    for wasm_file in build_dir.rglob("*.wasm"):
        relative_path = wasm_file.relative_to(build_dir)
        wasm_files.append(str(relative_path))
        
        # Copy to dist with same structure
        dest_file = dist_dir / relative_path
        dest_file.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(wasm_file, dest_file)
        print(f"üìã Copied: {relative_path}")
    
    if not wasm_files:
        print("‚ö†Ô∏è  Warning: No .wasm files found in build directory")
        print("üí° Run 'roe compile' or 'roe run' on some files first")
    
    # Generate manifest.json
    main_wasm = None
    if main_file:
        # Convert main .roe file to expected .wasm path
        main_stem = Path(main_file).stem
        # Look for matching .wasm file in the list
        for wasm_file in wasm_files:
            if Path(wasm_file).stem == main_stem:
                main_wasm = wasm_file
                break
    
    manifest = {
        "name": project_root.name,
        "version": "1.0.0",
        "description": f"Roelang project: {project_root.name}",
        "main": main_wasm or (wasm_files[0] if wasm_files else None),
        "files": wasm_files,
        "build_time": __import__('datetime').datetime.now().isoformat(),
        "roelang_version": "1.0.0"
    }
    
    manifest_path = dist_dir / "manifest.json"
    with open(manifest_path, "w") as f:
        json.dump(manifest, f, indent=2)
    
    print(f"üìÑ Created manifest.json")
    print(f"‚úÖ Distribution built successfully!")
    print(f"üì¶ {len(wasm_files)} files copied to {dist_dir}")
    if main_wasm:
        print(f"üéØ Main entry: {main_wasm}")

# Command line parsing
if len(sys.argv) < 2:
    print("Usage:\n  roe init\n  roe compile <filename>\n  roe run <filename>\n  roe build")
    exit(1)

command = sys.argv[1]

if command == "init":
    init_project()
    exit(0)

if command == "build":
    # Build command doesn't need additional arguments - handle it separately
    project_root = find_project_root()
    build_distribution(project_root)
    exit(0)
elif len(sys.argv) < 3:
    print("Usage:\n  roe compile <filename>\n  roe run <filename>\n  roe build")
    exit(1)

roe_filename = sys.argv[2]

# Determine project root
project_root = find_project_root()
config = load_config()

# Resolve paths
config_build_dir = project_root / config["build"]
tool_dir = Path.home() / ".roelang"
runtime = tool_dir / "run.js"

# Handle file path relative to current working directory
roe_file = Path(roe_filename)
if not roe_file.is_absolute():
    roe_file = Path.cwd() / roe_filename

# Create build directory based on source file location
# Calculate relative path from project root
if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
    relative_path = roe_file.relative_to(project_root)
elif not roe_file.is_absolute():
    # For relative paths, calculate from project root
    absolute_roe_file = roe_file.resolve()
    if absolute_roe_file.is_relative_to(project_root):
        relative_path = absolute_roe_file.relative_to(project_root)
    else:
        # File is outside project root, just use the filename
        relative_path = Path(roe_file.name)
else:
    # Absolute path outside project root
    relative_path = Path(roe_file.name)

basename = roe_file.stem

# Determine build directory - always use build/ with maintained structure
build_dir = config_build_dir

# Maintain source directory structure in build directory
if relative_path.parent != Path("."):
    # Source is in a subdirectory, maintain that structure in build
    build_dir = build_dir / relative_path.parent

wat_file = build_dir / f"{basename}.wat"
wasm_file = build_dir / f"{basename}.wasm"

# Validations
if not roe_file.exists() or not roe_file.suffix == ".roe":
    print(f"‚ùå Error: {roe_file} not found or not a .roe file")
    exit(1)

# Ensure build directory exists
build_dir.mkdir(parents=True, exist_ok=True)

# Compile to .wat
# Try new compiler API first, then fallback to old
if hasattr(compiler, 'compile_file'):
    compiler.compile_file(str(roe_file), str(wat_file))
else:
    compiler.compile_roe_to_wat(roe_file, wat_file)

# Compile to .wasm
os.system(f"wat2wasm {wat_file} -o {wasm_file}")

# Run if needed
if command == "run":
    os.system(f"node {runtime} {wasm_file}")
