#!/usr/bin/env python3

import os
import sys
import json
import argparse
import shutil
import subprocess
import time
from pathlib import Path
import importlib.util
from datetime import datetime
from urllib.parse import urlparse
import tempfile
import sqlite3
import hashlib

# SQLite database management for Puck JSON storage
def init_puck_database():
    """Initialize SQLite database for storing Puck JSON compilations."""
    db_path = Path.home() / ".droelang" / "puck_compilations.db"
    db_path.parent.mkdir(parents=True, exist_ok=True)
    
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    # Create table for Puck compilations
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS puck_compilations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_id TEXT,
            file_path TEXT NOT NULL,
            dsl_source TEXT NOT NULL,
            dsl_hash TEXT NOT NULL,
            puck_json TEXT NOT NULL,
            compiled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(project_id, file_path)
        )
    ''')
    
    # Create index for faster lookups
    cursor.execute('''
        CREATE INDEX IF NOT EXISTS idx_puck_project_file 
        ON puck_compilations(project_id, file_path)
    ''')
    
    conn.commit()
    conn.close()
    return db_path

def store_puck_compilation(file_path, dsl_source, puck_json, project_id=None):
    """Store Puck JSON compilation in SQLite database."""
    db_path = init_puck_database()
    
    # Calculate hash of DSL source for change detection
    dsl_hash = hashlib.sha256(dsl_source.encode()).hexdigest()
    
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    try:
        cursor.execute('''
            INSERT OR REPLACE INTO puck_compilations 
            (project_id, file_path, dsl_source, dsl_hash, puck_json, compiled_at)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (project_id, str(file_path), dsl_source, dsl_hash, puck_json, datetime.now()))
        
        conn.commit()
        compilation_id = cursor.lastrowid
        return compilation_id
    finally:
        conn.close()

def get_puck_compilation(file_path, project_id=None):
    """Retrieve Puck JSON compilation from database."""
    db_path = Path.home() / ".droelang" / "puck_compilations.db"
    if not db_path.exists():
        return None
    
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    try:
        cursor.execute('''
            SELECT puck_json, dsl_hash, compiled_at 
            FROM puck_compilations 
            WHERE project_id = ? AND file_path = ?
        ''', (project_id, str(file_path)))
        
        result = cursor.fetchone()
        if result:
            return {
                'puck_json': result[0],
                'dsl_hash': result[1],
                'compiled_at': result[2]
            }
        return None
    finally:
        conn.close()

def check_puck_cache(file_path, dsl_source, project_id=None):
    """Check if Puck compilation is cached and still valid."""
    cached = get_puck_compilation(file_path, project_id)
    if not cached:
        return False, None
    
    # Check if DSL source has changed
    current_hash = hashlib.sha256(dsl_source.encode()).hexdigest()
    if cached['dsl_hash'] != current_hash:
        return False, None
    
    return True, cached['puck_json']

def convert_puck_to_dsl_file(puck_json_file, output_dsl_file=None, target="html"):
    """Convert Puck JSON file back to DSL."""
    puck_file = Path(puck_json_file)
    if not puck_file.exists() or not puck_file.suffix == ".json":
        print(f"‚ùå Error: {puck_file} not found or not a JSON file")
        return False
    
    # Read Puck JSON
    try:
        with open(puck_file, 'r') as f:
            puck_json_str = f.read()
    except Exception as e:
        print(f"‚ùå Error reading Puck JSON: {e}")
        return False
    
    # Set output file
    if output_dsl_file:
        dsl_file = Path(output_dsl_file)
    else:
        dsl_file = puck_file.with_suffix('.droe')
    
    try:
        # Import reverse converter
        from compiler.targets.puck.reverse_codegen import convert_puck_to_dsl
        
        # Convert with target metadata
        metadata = {"target": target}
        dsl_content = convert_puck_to_dsl(puck_json_str, metadata)
        
        # Write DSL file
        with open(dsl_file, 'w') as f:
            f.write(dsl_content)
        
        print(f"‚úÖ Converted Puck JSON to DSL -> {dsl_file}")
        return True
        
    except Exception as e:
        print(f"‚ùå Conversion failed: {e}")
        return False

# Load compiler from ~/.droelang/
def load_compiler():
    # First try to load the new modular compiler
    compiler_module_path = Path.home() / ".droelang" / "compiler"
    if compiler_module_path.exists() and (compiler_module_path / "__init__.py").exists():
        # Add the parent directory to sys.path so we can import the module
        sys.path.insert(0, str(Path.home() / ".droelang"))
        try:
            from compiler import compiler
            return compiler
        except ImportError:
            pass
    
    # Fallback to standalone compiler
    compiler_path = Path.home() / ".droelang" / "compiler.py"
    if not compiler_path.exists():
        print("‚ùå Error: compiler not found in ~/.droelang/")
        exit(1)

    spec = importlib.util.spec_from_file_location("compiler", str(compiler_path))
    compiler = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(compiler)
    return compiler

# Load config from droeconfig.json if available
def load_config(project_root=None):
    default_config = {"src": "src", "build": "build", "target": "droe", "framework": "plain"}
    if project_root is None:
        config_path = Path.cwd() / "droeconfig.json"
    else:
        config_path = project_root / "droeconfig.json"
    
    if config_path.exists():
        try:
            with open(config_path) as f:
                config = json.load(f)
                return {
                    "src": config.get("src", "src"),
                    "build": config.get("build", "build"),
                    "target": config.get("target", "droe"),
                    "framework": config.get("framework", "plain"),
                    "package": config.get("package"),
                    "database": config.get("database")
                }
        except Exception as e:
            print(f"‚ùå Error reading droeconfig.json: {e}")
            exit(1)
    return default_config

# Interactive guided initialization
def guided_init():
    """Interactive project setup with prompts for all configuration."""
    print("üöÄ Welcome to Droelang Project Setup!")
    print("Let's create your new project step by step.\n")
    
    # Project name
    while True:
        name = input("üìù Project name (or press Enter for current directory): ").strip()
        if not name:
            # Use current directory
            break
        if not name.replace('-', '').replace('_', '').replace('.', '').isalnum():
            print("‚ùå Project name should only contain letters, numbers, hyphens, and underscores")
            continue
        break
    
    # Author
    author = input("üë§ Author name (optional): ").strip() or None
    
    # Target selection
    print("\nüéØ Choose your target platform:")
    targets = [
        ("droe", "Droe VM (Fast bytecode execution)"),
        ("html", "Web Applications (HTML/CSS/JS)"),
        ("mobile", "Mobile Apps (Android/iOS)"),
        ("java", "Java Applications"),
        ("python", "Python Applications"),
        ("go", "Go Applications"),
        ("node", "Node.js Applications"),
        ("rust", "Rust Applications"),
        ("wasm", "WebAssembly (Generic)")
    ]
    
    for i, (target_key, description) in enumerate(targets, 1):
        print(f"  {i}. {target_key:<8} - {description}")
    
    while True:
        try:
            choice = input(f"\nSelect target (1-{len(targets)}) [1]: ").strip()
            if not choice:
                target = "droe"
                break
            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(targets):
                target = targets[choice_idx][0]
                break
            else:
                print(f"‚ùå Please enter a number between 1 and {len(targets)}")
        except ValueError:
            print("‚ùå Please enter a valid number")
    
    # Framework selection
    framework = None
    framework_options = {
        "java": [("spring", "Spring Boot Framework")],
        "python": [("fastapi", "FastAPI Framework")],
        "go": [("fiber", "Fiber Framework")],
        "node": [("fastify", "Fastify Framework")],
        "rust": [("axum", "Axum Framework")],
        "droe": [("axum", "Axum Framework")]
    }
    
    if target in framework_options:
        print(f"\nüõ†Ô∏è  Choose framework for {target}:")
        frameworks = [("plain", "No Framework")] + framework_options[target]
        
        for i, (fw_key, description) in enumerate(frameworks, 1):
            print(f"  {i}. {fw_key:<10} - {description}")
        
        while True:
            try:
                choice = input(f"Select framework (1-{len(frameworks)}) [1]: ").strip()
                if not choice:
                    framework = "plain"
                    break
                choice_idx = int(choice) - 1
                if 0 <= choice_idx < len(frameworks):
                    framework = frameworks[choice_idx][0]
                    break
                else:
                    print(f"‚ùå Please enter a number between 1 and {len(frameworks)}")
            except ValueError:
                print("‚ùå Please enter a valid number")
    
    # Database configuration for targets that commonly need it
    database_config = None
    database_host = None
    database_port = None
    database_name = None
    database_user = None
    database_password = None
    
    if target in ["html", "mobile", "java", "python", "go", "node", "rust", "droe"] and framework != "plain":
        print(f"\nüóÑÔ∏è  Database Configuration:")
        needs_db = input("Do you need database support? (y/N): ").strip().lower()
        
        if needs_db in ['y', 'yes']:
            print("\nDatabase options:")
            db_options = [
                ("postgresql", "PostgreSQL"),
                ("mysql", "MySQL/MariaDB"),
                ("sqlite", "SQLite (local file)"),
                ("mongodb", "MongoDB")
            ]
            
            for i, (db_key, description) in enumerate(db_options, 1):
                print(f"  {i}. {db_key:<12} - {description}")
            
            while True:
                try:
                    choice = input(f"Select database (1-{len(db_options)}) [1]: ").strip()
                    if not choice:
                        database_config = "postgresql"
                        break
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(db_options):
                        database_config = db_options[choice_idx][0]
                        break
                    else:
                        print(f"‚ùå Please enter a number between 1 and {len(db_options)}")
                except ValueError:
                    print("‚ùå Please enter a valid number")
            
            # Get database connection details for non-SQLite databases
            if database_config != "sqlite":
                print(f"\nüì° {database_config.title()} Connection Details:")
                database_host = input(f"Host [localhost]: ").strip() or "localhost"
                
                default_ports = {"postgresql": "5432", "mysql": "3306", "mongodb": "27017"}
                default_port = default_ports.get(database_config, "5432")
                database_port = input(f"Port [{default_port}]: ").strip() or default_port
                
                database_name = input(f"Database name [{'my' + name.replace('-', '_') if name else 'myapp'}]: ").strip()
                if not database_name:
                    database_name = 'my' + name.replace('-', '_') if name else 'myapp'
                
                database_user = input(f"Username [postgres]: ").strip() or "postgres"
                database_password = input(f"Password (optional): ").strip() or None
    
    print(f"\nüìã Project Summary:")
    print(f"   üìÅ Name: {name or 'current directory'}")
    if author:
        print(f"   üë§ Author: {author}")
    print(f"   üéØ Target: {target}")
    if framework and framework != "plain":
        print(f"   üõ†Ô∏è  Framework: {framework}")
    if database_config:
        print(f"   üóÑÔ∏è  Database: {database_config}")
        if database_host and database_config != "sqlite":
            print(f"   üì° DB Host: {database_host}:{database_port}")
            print(f"   üè∑Ô∏è  DB Name: {database_name}")
            print(f"   üë§ DB User: {database_user}")
    
    confirm = input(f"\n‚úÖ Create project? (Y/n): ").strip().lower()
    if confirm in ['', 'y', 'yes']:
        # Call the existing init_project with gathered parameters
        return init_project_with_db(name, author, target, framework, database_config, 
                                  database_host, database_port, database_name, 
                                  database_user, database_password)
    else:
        print("‚ùå Project creation cancelled")
        return False

# Enhanced init_project with database support
def init_project_with_db(name=None, author=None, target=None, framework=None, 
                        database=None, db_host=None, db_port=None, db_name=None, 
                        db_user=None, db_password=None):
    """Initialize project with database configuration support."""
    return init_project_enhanced(name, author, target, framework, database, 
                                db_host, db_port, db_name, db_user, db_password)

# Compatibility wrapper for existing code
def init_project(name=None, author=None, target=None, framework=None):
    """Backward compatibility wrapper for init_project."""
    return init_project_enhanced(name, author, target, framework)

def init_project_enhanced(name=None, author=None, target=None, framework=None,
                         database=None, db_host=None, db_port=None, db_name=None, 
                         db_user=None, db_password=None):
    """Enhanced version of init_project with database support."""
    # If name is provided, create a directory for the project
    if name:
        project_root = Path.cwd() / name
        
        # Check if directory already exists
        if project_root.exists():
            if project_root.is_dir():
                if any(project_root.iterdir()):
                    print(f"‚ùå Error: Directory '{name}' already exists and is not empty")
                    print(f"üìÅ Directory: {project_root}")
                    print("üí° Choose a different project name or remove the existing directory")
                    exit(1)
            else:
                print(f"‚ùå Error: A file named '{name}' already exists")
                print(f"üìÅ Location: {project_root}")
                print("üí° Choose a different project name")
                exit(1)
        
        # Create the project directory
        project_root.mkdir(parents=True, exist_ok=True)
        print(f"üìÅ Created project directory: {name}/")
    else:
        # Use current directory
        project_root = Path.cwd()
        
        # Check if directory is not empty
        if any(project_root.iterdir()):
            config_path = project_root / "droeconfig.json"
            if config_path.exists():
                print("‚ùå Error: This directory already contains a Droelang project")
                print(f"üìÅ Current directory: {project_root}")
                print("üí° Use a new empty directory to create a different project")
            else:
                print("‚ùå Error: Directory is not empty")
                print(f"üìÅ Current directory: {project_root}")
                print("üí° 'droe init' must be run in an empty directory or provide a project name")
            exit(1)
    
    src_dir = project_root / "src"
    build_dir = project_root / "build"
    modules_dir = project_root / "modules"
    config_path = project_root / "droeconfig.json"

    # Create directories
    src_dir.mkdir(exist_ok=True)
    build_dir.mkdir(exist_ok=True)
    modules_dir.mkdir(exist_ok=True)

    # Initialize config_data (always available)
    config_data = {
        "src": "src",
        "build": "build",
        "dist": "dist",
        "modules": "modules",
        "main": "src/main.droe",
        "target": target or "droe"
    }
    
    # Validate framework-target compatibility
    if framework:
        valid_frameworks = {
            "java": ["spring"],
            "python": ["fastapi"],
            "go": ["fiber"],
            "node": ["fastify"],
            "wasm": [],
            "html": [],
            "mobile": [],
            "rust": ["axum"],
            "droe": ["axum"]
        }
        
        target_key = target or "droe"
        if target_key in valid_frameworks:
            if framework != "plain" and framework not in valid_frameworks[target_key]:
                print(f"‚ùå Error: Framework '{framework}' is not compatible with target '{target_key}'")
                if valid_frameworks[target_key]:
                    print(f"üí° Valid frameworks for {target_key}: {', '.join(valid_frameworks[target_key])}")
                else:
                    print(f"üí° Target '{target_key}' does not support frameworks")
                exit(1)
        
        # Add framework if specified and applicable (ignore for targets that don't support frameworks)
        if framework != "plain" and target_key in ["java", "python", "go", "node", "rust", "droe"]:
            config_data["framework"] = framework
        
    # Add package name for Java Spring projects
    if target == "java" and framework == "spring":
        if name:
            # Convert project name to Java package name format
            package_name = "com.example." + name.lower().replace("-", "").replace("_", "")
        else:
            package_name = "com.example.app"
        config_data["package"] = package_name
        config_data["database"] = database or "postgresql"  # Use provided or default database for Spring
    
    # Add database configuration for other targets if specified
    if database and target not in ["java"]:  # Java already handled above
        config_data["database"] = database
        if db_host:
            config_data["database_config"] = {
                "host": db_host,
                "port": int(db_port) if db_port else None,
                "name": db_name,
                "user": db_user,
                "password": db_password
            }

    # Create droeconfig.json
    if not config_path.exists():
        with open(config_path, "w") as f:
            json.dump(config_data, f, indent=2)
        print("‚úÖ Created droeconfig.json")
    else:
        # If config exists, load it to preserve existing values
        with open(config_path) as f:
            existing_config = json.load(f)
            # Use existing config but allow override of target/framework from command line
            for key in ["target", "framework", "package", "database"]:
                if key in config_data:
                    existing_config[key] = config_data[key]
            config_data = existing_config


    # Create a sample main.droe file
    main_file = src_dir / "main.droe"
    if not main_file.exists():
        # Generate target-specific sample content  
        project_name = name or project_root.name
        
        if target == "java" and framework == "spring":
            main_content = f'''@target java
@framework spring
@package {config_data.get("package", "com.example.app")}

module IndexModule

action Index gives text
    set projectName which is text to "{project_name}"
    give projectName
end action

end module

api IndexAPI
    endpoint GET /
        return from IndexModule.Index
    end
end
'''
        elif target == "html":
            main_content = f'''@target html

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "mobile":
            main_content = f'''@target mobile

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "python":
            main_content = f'''@target python

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "go":
            main_content = f'''@target go

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        elif target == "node":
            main_content = f'''@target node

set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        else:
            # Default WASM/generic content
            main_content = f'''set projectName which is text to "{project_name}"
display "Hello from [projectName]!"
'''
        with open(main_file, "w") as f:
            f.write(main_content)
        print("‚úÖ Created src/main.droe")

    print("‚úÖ Initialized Droelang project successfully!")
    print(f"üìÅ Project name: {name or project_root.name}")
    if author:
        print(f"üë§ Author: {author}")
    # Show framework only for targets that support it
    framework_targets = ["java", "python", "go", "node"] 
    show_framework = framework and framework != "plain" and (target or "wasm") in framework_targets
    print(f"üéØ Target: {target or 'droe'}" + (f" with {framework} framework" if show_framework else ""))
    print("\nüìÇ Directory structure:")
    print("  src/         - Source code (.droe files)")
    print("  modules/     - Downloaded packages")
    print("  build/       - Compiled files")
    print("  dist/        - Distribution packages")
    print("\nüöÄ Next steps:")
    if name:  # If a project directory was created
        print(f"  cd {name}/              - Navigate to project directory")
        print("  droe run src/main.droe     - Run the sample")
        print("  droe build               - Build project")
    else:  # If initialized in current directory
        print("  droe run src/main.droe     - Run the sample")
        print("  droe build               - Build project")

# Package management functions
def install_package(package_name, is_dev=False):
    """Install a package from a repository."""
    project_root = find_project_root()
    modules_dir = project_root / "modules"
    package_path = project_root / "package.json"
    
    # Create modules directory if it doesn't exist
    modules_dir.mkdir(exist_ok=True)
    
    # Load package.json
    if not package_path.exists():
        print("‚ùå Error: package.json not found. Run 'droe init' first.")
        exit(1)
    
    with open(package_path) as f:
        package_data = json.load(f)
    
    print(f"üì¶ Installing {package_name}...")
    
    # For now, simulate package installation from a registry
    # In a real implementation, this would:
    # 1. Resolve package name to repository URL
    # 2. Download from git/registry
    # 3. Extract .droe files to modules directory
    
    package_dir = modules_dir / package_name
    
    # Simulate package download (create example package structure)
    if package_name == "math-utils":
        package_dir.mkdir(exist_ok=True)
        
        # Create example DSL files
        math_roe = package_dir / "math.droe"
        with open(math_roe, "w") as f:
            f.write('''# Math utilities package
module MathUtils
    action add with a which is int and b which is int returns int
        return a + b
    end
    
    action multiply with x which is decimal and y which is decimal returns decimal
        return x * y
    end
    
    action power with base which is int and exp which is int returns int
        set result which is int to 1
        set i which is int to 0
        while i < exp
            set result to result * base
            set i to i + 1
        end
        return result
    end
end
''')
        
        package_info = package_dir / "package.json"
        with open(package_info, "w") as f:
            json.dump({
                "name": "math-utils",
                "version": "1.0.0",
                "description": "Mathematical utility functions for Droelang",
                "main": "math.droe",
                "files": ["math.droe"]
            }, f, indent=2)
        
        print(f"‚úÖ Downloaded math-utils to modules/{package_name}")
    elif package_name == "string-utils":
        package_dir.mkdir(exist_ok=True)
        
        string_roe = package_dir / "strings.droe"
        with open(string_roe, "w") as f:
            f.write('''# String utilities package
module StringUtils
    action uppercase with text which is text returns text
        # Placeholder for uppercase functionality
        return text + " (UPPER)"
    end
    
    action concat_with_separator with items which are list of text and sep which is text returns text
        # Placeholder for join functionality
        return "Joined: " + items[0] + sep + items[1]
    end
end
''')
        
        print(f"‚úÖ Downloaded string-utils to modules/{package_name}")
    else:
        print(f"‚ùå Package '{package_name}' not found in registry")
        print("üí° Available packages: math-utils, string-utils")
        exit(1)
    
    # Update package.json dependencies
    dep_key = "devDependencies" if is_dev else "dependencies"
    if dep_key not in package_data:
        package_data[dep_key] = {}
    
    package_data[dep_key][package_name] = "^1.0.0"
    
    with open(package_path, "w") as f:
        json.dump(package_data, f, indent=2)
    
    print(f"‚úÖ Added {package_name} to {dep_key}")
    print(f"üí° Use: include \"{package_name}/{package_name.replace('-', '_')}.droe\"")

def clean_build(clean_all=False):
    """Clean build directory and optionally dist directory."""
    project_root = find_project_root()
    config = load_config(project_root)
    
    build_dir = project_root / config.get("build", "build")
    dist_dir = project_root / config.get("dist", "dist")
    
    cleaned_dirs = []
    
    # Clean build directory
    if build_dir.exists():
        shutil.rmtree(build_dir)
        cleaned_dirs.append(str(build_dir.name))
        print(f"üßπ Cleaned {build_dir}")
    else:
        print(f"‚ÑπÔ∏è  Build directory {build_dir} doesn't exist")
    
    # Clean dist directory if --all flag is used
    if clean_all:
        if dist_dir.exists():
            shutil.rmtree(dist_dir)
            cleaned_dirs.append(str(dist_dir.name))
            print(f"üßπ Cleaned {dist_dir}")
        else:
            print(f"‚ÑπÔ∏è  Dist directory {dist_dir} doesn't exist")
    
    if cleaned_dirs:
        print(f"‚úÖ Cleaned {len(cleaned_dirs)} director{'y' if len(cleaned_dirs) == 1 else 'ies'}: {', '.join(cleaned_dirs)}")
    else:
        print("‚ÑπÔ∏è  Nothing to clean")

def show_version():
    """Show version information."""
    print("Roe Lang Compiler & Runtime")
    print("Version: 1.0.0")
    print("Build: 2024-08-06")
    print("")
    print("Components:")
    print("  - Compiler: Python-based DSL to WebAssembly")
    print("  - Runtime: Node.js WebAssembly executor")
    print("  - Package Manager: Module-based dependency system")

def show_help():
    """Show comprehensive help information."""
    print("Roe Lang - Domain Specific Language Compiler")
    print("")
    print("USAGE:")
    print("    droe [COMMAND] [OPTIONS]")
    print("")
    print("COMMANDS:")
    print("    init [name]             Initialize new Droelang project")
    print("    compile <file>          Compile .droe file to target language")
    print("    run <file>              Compile and run .droe file")
    print("    build                   Build entire project")
    print("    clean                   Clean build directory")
    print("    install [package]       Install package dependencies")
    print("")
    print("INIT OPTIONS:")
    print("    name                    Project name (creates directory if specified)")
    print("    --author <author>       Set project author")
    print("    --target <target>       Set compilation target (wasm|python|java|go|node|html|mobile)")
    print("    --framework <fw>        Set framework (spring|fastapi|fiber|fastify)")
    print("")
    print("INSTALL OPTIONS:")
    print("    --dev                   Install as development dependency")
    print("")
    print("BUILD OPTIONS:")
    print("    --clean                 Clean build directory first")
    print("    --release               Build for production (optimized)")
    print("")
    print("CLEAN OPTIONS:")
    print("    --all                   Also clean dist directory")
    print("")
    print("COMPILE OPTIONS:")
    print("    --format <fmt>          Output format (wat|wasm) [default: wasm]")
    print("    --output <path>         Output file path")
    print("    --watch                 Watch for file changes")
    print("")
    print("RUN OPTIONS:")
    print("    --watch                 Watch and rerun on changes")
    print("")
    print("GLOBAL OPTIONS:")
    print("    -h, --help              Show this help message")
    print("    --version               Show version information")
    print("")
    print("EXAMPLES:")
    print("    droe init my-app --author \"John Doe\"")
    print("    droe init my-api --target java --framework spring")
    print("    droe init api-server --target python --framework fastapi")
    print("    droe init web-server --target go --framework fiber") 
    print("    droe init node-api --target node --framework fastify")
    print("    droe init web-app --target html")
    print("    droe init my-mobile-app --target mobile")
    print("    droe init --target python                      # Initialize in current directory")
    print("    droe install math-utils")
    print("    droe install dev-tools --dev")
    print("    droe compile src/main.droe --target java")
    print("    droe compile src/main.droe --format wasm --output dist/main.wasm")
    print("    droe run src/main.droe --watch")
    print("    droe build --clean --release")
    print("    droe clean")
    print("    droe clean --all")

# Load compiler
compiler = load_compiler()

# Find project root by looking for droeconfig.json
def find_project_root():
    """Find the project root by looking for droeconfig.json up to 10 levels."""
    current = Path.cwd()
    original = current
    root = current.root
    max_depth = 10  # Look up to 10 levels
    depth = 0
    
    # Look for droeconfig.json in current and parent directories (up to max_depth)
    while current != Path(root) and depth < max_depth:
        if (current / "droeconfig.json").exists():
            return current
        
        parent = current.parent
        if parent == current:
            break
        current = parent
        depth += 1
    
    # No droeconfig.json found - require user to create one
    print(f"‚ùå Error: No droeconfig.json found (searched up {depth} directories)")
    print(f"üìÇ Current directory: {original}")
    print(f"\nüí° To create a Droelang project, run: droe init")
    print(f"   This will create droeconfig.json in the current directory")
    exit(1)

# Build distribution package
def build_distribution(project_root, clean=False, release=False):
    """Build distribution package with manifest.json and .wasm files."""
    import shutil
    import subprocess
    from glob import glob
    
    # Load config
    config_path = project_root / "droeconfig.json"
    if not config_path.exists():
        print("‚ùå Error: droeconfig.json not found")
        exit(1)
    
    with open(config_path) as f:
        config = json.load(f)
    
    # Get config values with defaults
    src_pattern = config.get("src", ".")
    build_dir = project_root / config.get("build", "build")
    dist_dir = project_root / config.get("dist", "dist")
    main_file = config.get("main", "src/main.droe")
    target = config.get("target", "droe")
    framework = config.get("framework", "plain")
    
    print(f"üì¶ Building distribution package...")
    print(f"üéØ Target: {target}" + (f" ({framework})" if framework != "plain" else ""))
    if release:
        print("üöÄ Release build (optimized)")
    if clean:
        print("üßπ Cleaning build directory")
    print(f"üìÇ Source pattern: {src_pattern}")
    print(f"üìÇ Build directory: {build_dir}")
    print(f"üìÇ Dist directory: {dist_dir}")
    print(f"üéØ Main entry: {main_file}")
    
    # Clean build directory if requested
    if clean and build_dir.exists():
        shutil.rmtree(build_dir)
        print(f"üßπ Cleaned {build_dir}")
    
    # Find all .droe files in the project
    if src_pattern == ".":
        search_root = project_root
    else:
        search_root = project_root / src_pattern
    
    roe_files = []
    if search_root.exists():
        roe_files = list(search_root.rglob("*.droe"))
    
    if not roe_files:
        print(f"‚ö†Ô∏è  Warning: No .droe files found in {search_root}")
        print("üí° Add some .droe files to your project first")
    else:
        print(f"üîç Found {len(roe_files)} .droe files to compile:")
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            print(f"   {rel_path}")
        
        # Compile all .droe files
        print(f"üî® Compiling {len(roe_files)} files...")
        compiled_count = 0
        failed_count = 0
        
        for roe_file in roe_files:
            rel_path = roe_file.relative_to(project_root)
            try:
                # Use subprocess to call droe compile for each file
                result = subprocess.run([
                    sys.executable, str(Path.home() / ".droelang" / "bin" / "droe"), 
                    "compile", str(rel_path)
                ], cwd=project_root, capture_output=True, text=True)
                
                if result.returncode == 0:
                    compiled_count += 1
                    print(f"   ‚úÖ {rel_path}")
                else:
                    failed_count += 1
                    print(f"   ‚ùå {rel_path}: {result.stderr.strip()}")
            except Exception as e:
                failed_count += 1
                print(f"   ‚ùå {rel_path}: {e}")
        
        print(f"üìä Compilation complete: {compiled_count} succeeded, {failed_count} failed")
        
        if failed_count > 0:
            print("‚ö†Ô∏è  Some files failed to compile. Distribution will only include successful compilations.")
    
    # Ensure build directory exists (might be created by compilation)
    build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create/clean dist directory
    if dist_dir.exists():
        shutil.rmtree(dist_dir)
    dist_dir.mkdir(parents=True, exist_ok=True)
    
    # Handle different target types
    copied_files = []
    main_entry = None
    
    if target == "java" and framework == "spring":
        # Handle Java Spring Boot projects
        print("üì± Packaging Spring Boot projects...")
        
        # Find all Spring Boot project directories in build
        for project_dir in build_dir.iterdir():
            if project_dir.is_dir() and (project_dir / "pom.xml").exists():
                relative_path = project_dir.relative_to(build_dir)
                
                # Copy entire Spring Boot project to dist
                dest_dir = dist_dir / relative_path
                shutil.copytree(project_dir, dest_dir, dirs_exist_ok=True)
                copied_files.append(str(relative_path))
                print(f"üìã Copied Spring Boot project: {relative_path}")
                
                # Set main entry to first project found
                if main_entry is None:
                    main_entry = str(relative_path)
        
        if not copied_files:
            print("‚ö†Ô∏è  Warning: No Spring Boot projects found in build directory")
            print("üí° Run 'droe compile' on your .droe files first")
    
    elif target == "mobile":
        # Handle mobile projects
        print("üì± Packaging mobile projects...")
        
        # Look for android/ios directories
        for mobile_dir in ["android", "ios"]:
            mobile_path = build_dir / mobile_dir
            if mobile_path.exists():
                dest_dir = dist_dir / mobile_dir
                shutil.copytree(mobile_path, dest_dir, dirs_exist_ok=True)
                copied_files.append(mobile_dir)
                print(f"üìã Copied mobile project: {mobile_dir}")
        
        if not copied_files:
            print("‚ö†Ô∏è  Warning: No mobile projects found in build directory")
            print("üí° Run 'droe compile' on your .droe files first")
    
    else:
        # Handle WASM and other single-file targets
        target_extensions = {
            "wasm": "*.wasm",
            "python": "*.py", 
            "java": "*.java",
            "go": "*.go",
            "node": "*.js",
            "html": "*.html",
            "rust": "*.rs",
            "droe": "*.droebc"
        }
        
        pattern = target_extensions.get(target, "*.droebc")
        print(f"üì¶ Looking for {pattern} files...")
        
        for target_file in build_dir.rglob(pattern):
            relative_path = target_file.relative_to(build_dir)
            copied_files.append(str(relative_path))
            
            # Copy to dist with same structure
            dest_file = dist_dir / relative_path
            dest_file.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(target_file, dest_file)
            print(f"üìã Copied: {relative_path}")
        
        if not copied_files:
            print(f"‚ö†Ô∏è  Warning: No {pattern} files found in build directory")
            print("üí° Run 'droe compile' or 'droe run' on some files first")
        
        # Set main entry for single-file targets
        if main_file and copied_files:
            main_stem = Path(main_file).stem
            for file_path in copied_files:
                if Path(file_path).stem == main_stem:
                    main_entry = file_path
                    break
            # Fallback to first file
            if main_entry is None and copied_files:
                main_entry = copied_files[0]
    
    # Generate manifest.json
    manifest = {
        "name": project_root.name,
        "version": "1.0.0",
        "description": config.get("description", f"Droelang project: {project_root.name}"),
        "target": target,
        "framework": framework if framework != "plain" else None,
        "main": main_entry,
        "files": copied_files,
        "build_time": __import__('datetime').datetime.now().isoformat(),
        "roelang_version": "1.0.0"
    }
    
    manifest_path = dist_dir / "manifest.json"
    with open(manifest_path, "w") as f:
        json.dump(manifest, f, indent=2)
    
    print(f"üìÑ Created manifest.json")
    print(f"‚úÖ Distribution built successfully!")
    print(f"üì¶ {len(copied_files)} files copied to {dist_dir}")
    if main_entry:
        print(f"üéØ Main entry: {main_entry}")

# Command line parsing with argparse
def main():
    parser = argparse.ArgumentParser(
        prog='droe',
        description='Roe Lang - Domain Specific Language Compiler',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Global flags
    parser.add_argument('--version', action='store_true', help='Show version information')
    
    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize new Droelang project')
    init_parser.add_argument('project_name', nargs='?', help='Project name (creates directory if specified)')
    init_parser.add_argument('--name', help='Project name (deprecated, use positional argument)')
    init_parser.add_argument('--author', help='Project author')
    init_parser.add_argument('--target', choices=['wasm', 'python', 'java', 'go', 'node', 'html', 'mobile', 'rust', 'droe'], help='Compilation target')
    init_parser.add_argument('--framework', choices=['plain', 'spring', 'fastapi', 'fiber', 'fastify', 'axum'], help='Framework to use with target')
    
    # Install command
    install_parser = subparsers.add_parser('install', help='Install package dependencies')
    install_parser.add_argument('package', nargs='?', help='Package name to install')
    install_parser.add_argument('--dev', action='store_true', help='Install as development dependency')
    
    # Build command
    build_parser = subparsers.add_parser('build', help='Build entire project')
    build_parser.add_argument('--clean', action='store_true', help='Clean build directory first')
    build_parser.add_argument('--release', action='store_true', help='Build for production')
    
    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Clean build directory')
    clean_parser.add_argument('--all', action='store_true', help='Also clean dist directory')
    
    # Compile command
    compile_parser = subparsers.add_parser('compile', help='Compile .droe file to specified target')
    compile_parser.add_argument('file', help='Source file to compile')
    compile_parser.add_argument('--format', choices=['wat', 'wasm'], help='Legacy output format (wat/wasm)')
    compile_parser.add_argument('--target', choices=['wasm', 'python', 'java', 'go', 'node', 'html', 'kotlin', 'swift', 'bytecode', 'mobile', 'rust', 'droe', 'puck'], help='Compilation target (overrides droeconfig.json)')
    compile_parser.add_argument('--output', help='Output file path')
    compile_parser.add_argument('--watch', action='store_true', help='Watch for file changes')
    
    # Reverse convert command (Puck JSON back to DSL)
    reverse_parser = subparsers.add_parser('reverse', help='Convert Puck JSON back to DSL')
    reverse_parser.add_argument('file', help='Puck JSON file to convert')
    reverse_parser.add_argument('--output', help='Output DSL file path')
    reverse_parser.add_argument('--target', choices=['html', 'mobile'], default='html', help='Target platform for DSL generation')
    
    # Run command
    run_parser = subparsers.add_parser('run', help='Compile and run .droe file')
    run_parser.add_argument('file', help='Source file to run')
    run_parser.add_argument('--watch', action='store_true', help='Watch and rerun on changes')
    
    # Handle legacy usage patterns
    if len(sys.argv) == 1 or (len(sys.argv) == 2 and sys.argv[1] in ['-h', '--help']):
        show_help()
        return
    
    # Handle version flag
    if len(sys.argv) == 2 and sys.argv[1] == '--version':
        show_version()
        return
    
    # Handle legacy command patterns
    if len(sys.argv) >= 2 and sys.argv[1] not in ['init', 'install', 'build', 'clean', 'compile', 'run', 'reverse', '--version', '-h', '--help']:
        if sys.argv[1] in ['-h', '--help']:
            show_help()
            return
        else:
            # Legacy usage - try to infer command
            print("‚ùå Unknown command. Use 'droe --help' for usage information.")
            return
    
    args = parser.parse_args()
    
    # Handle version flag
    if args.version:
        show_version()
        return
    
    # Handle commands
    if args.command == 'init':
        # Use positional argument if provided, otherwise fall back to --name flag
        project_name = args.project_name or args.name
        
        # If no parameters provided, use guided initialization
        if not any([project_name, args.author, args.target, args.framework]):
            guided_init()
        else:
            init_project_enhanced(project_name, args.author, args.target, args.framework)
        return
    
    elif args.command == 'install':
        if args.package:
            install_package(args.package, args.dev)
        else:
            # Install all dependencies from package.json
            project_root = find_project_root()
            package_path = project_root / "package.json"
            if package_path.exists():
                with open(package_path) as f:
                    package_data = json.load(f)
                
                dependencies = package_data.get('dependencies', {})
                dev_dependencies = package_data.get('devDependencies', {})
                
                print("üì¶ Installing dependencies...")
                for pkg in dependencies:
                    install_package(pkg, False)
                for pkg in dev_dependencies:
                    install_package(pkg, True)
            else:
                print("‚ùå Error: package.json not found. Run 'droe init' first.")
        return
    
    elif args.command == 'build':
        project_root = find_project_root()
        config = load_config(project_root)
        
        # Check if this is a mobile project
        if config.get('target') == 'mobile':
            build_mobile_project(project_root, args.clean, args.release)
        else:
            build_distribution(project_root, args.clean, args.release)
        return
    
    elif args.command == 'clean':
        clean_build(args.all)
        return
    
    elif args.command == 'compile':
        # Handle format vs target arguments
        output_format = args.format or 'wasm'
        target_override = args.target
        compile_file(args.file, output_format, args.output, args.watch, target_override)
        return
    
    elif args.command == 'reverse':
        # Convert Puck JSON back to DSL
        success = convert_puck_to_dsl_file(args.file, args.output, args.target)
        if not success:
            exit(1)
        return
    
    elif args.command == 'run':
        run_file(args.file, args.watch)
        return
    
    else:
        show_help()

def compile_file(roe_filename, output_format='wasm', output_path=None, watch=False, target_override=None):
    """Compile a single .droe file."""
    def do_compile():
        # Determine project root
        project_root = find_project_root()
        config = load_config(project_root)
        
        # Resolve paths
        config_build_dir = project_root / config["build"]
        tool_dir = Path.home() / ".droelang"
        
        # Handle file path relative to current working directory
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        # Calculate relative path for build directory structure
        if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
            relative_path = roe_file.relative_to(project_root)
        else:
            relative_path = Path(roe_file.name)
        
        basename = roe_file.stem
        
        # Determine build directory
        build_dir = config_build_dir
        if relative_path.parent != Path("."):
            build_dir = build_dir / relative_path.parent
        
        # Set output files
        if output_path:
            if output_format == 'wat':
                wat_file = Path(output_path)
                wasm_file = wat_file.with_suffix('.wasm')
            else:
                wasm_file = Path(output_path)
                wat_file = wasm_file.with_suffix('.wat')
        else:
            wat_file = build_dir / f"{basename}.wat"
            wasm_file = build_dir / f"{basename}.wasm"
        
        # Validations
        if not roe_file.exists() or not roe_file.suffix == ".droe":
            print(f"‚ùå Error: {roe_file} not found or not a .droe file")
            exit(1)
        
        # Ensure build directory exists
        wat_file.parent.mkdir(parents=True, exist_ok=True)
        
        try:
            # Read source to check for @target metadata
            with open(roe_file, 'r') as f:
                source_content = f.read()
            
            # Determine target language with correct priority:
            # 1. CLI target override (--target)
            # 2. DSL metadata (@target) 
            # 3. Project config target
            # 4. Default wasm
            if target_override:
                target = target_override
            else:
                config_target = config.get("target", "droe")
                target = compiler.get_target_from_source(source_content, config_target)
            
            # If output_format is specified and not 'wasm', it's likely wat - keep backward compatibility
            if not target_override and output_format == 'wat':
                target = 'wasm'  # WAT is part of WASM target
            
            print(f"üî® Compiling {roe_file} -> {target.upper()}")
            
            # Use new multi-target compiler if available
            if hasattr(compiler, 'compile_file') and hasattr(compiler, 'CompilerError'):
                try:
                    # For mobile and rust targets, don't create individual output paths
                    if target in ['mobile', 'rust']:
                        # These projects handle their own directory structure
                        output_file = compiler.compile_file(str(roe_file), target=target, framework=config.get("framework", "plain"), package=config.get("package"), database=config.get("database"))
                    else:
                        # Calculate output path for build directory if not specified
                        if output_path is None:
                            # Determine the appropriate file extension for the target
                            target_extensions = {
                                'wasm': '.wat',
                                'python': '.py', 
                                'java': '.java',
                                'go': '.go',
                                'node': '.js',
                                'html': '.html',
                                'kotlin': '.kt',
                                'swift': '.swift',
                                'bytecode': '.droebc',
                                'rust': '.rs',
                                'droe': '.droebc',
                                'puck': '.puck.json'
                            }
                            extension = target_extensions.get(target, '.txt')
                            computed_output_path = build_dir / f"{basename}{extension}"
                        else:
                            computed_output_path = Path(output_path)
                        
                        # Ensure build directory exists
                        computed_output_path.parent.mkdir(parents=True, exist_ok=True)
                        
                        output_file = compiler.compile_file(str(roe_file), output_path=str(computed_output_path), target=target, framework=config.get("framework", "plain"), package=config.get("package"), database=config.get("database"))
                    
                    # Special handling for Puck target - store in SQLite
                    if target == 'puck':
                        # Get project ID from config or use directory name
                        project_id = config.get('name', project_root.name if project_root else 'default')
                        
                        # Check cache first
                        is_cached, cached_json = check_puck_cache(roe_file, source_content, project_id)
                        if is_cached:
                            print(f"‚úÖ Using cached Puck JSON (no changes detected)")
                            output_file = cached_json
                        else:
                            # Read the compiled Puck JSON
                            if isinstance(output_file, str) and Path(output_file).exists():
                                with open(output_file, 'r') as f:
                                    puck_json = f.read()
                            else:
                                puck_json = str(output_file)
                            
                            # Store in database
                            compilation_id = store_puck_compilation(roe_file, source_content, puck_json, project_id)
                            print(f"üíæ Stored Puck JSON in database (ID: {compilation_id})")
                    
                    # Handle different types of compilation results
                    if isinstance(output_file, dict) and 'files' in output_file:
                        # Multi-file project (like Spring Boot)
                        project_root = output_file.get('project_root', 'project')
                        num_files = len(output_file.get('files', {}))
                        print(f"‚úÖ Compiled successfully -> {project_root}/ ({num_files} files)")
                    else:
                        # Single file result
                        print(f"‚úÖ Compiled successfully -> {output_file}")
                    
                    # Runtime files are no longer needed - using inline code generation
                    print("‚ÑπÔ∏è  Runtime dependency eliminated - using native language features")
                    
                    # Handle backward compatibility for wasm format
                    if target == 'wasm' and output_format == 'wasm' and isinstance(output_file, str):
                        # For WASM target, also generate .wasm file using wat2wasm
                        if output_file.endswith('.wat'):
                            wasm_output = output_file.replace('.wat', '.wasm')
                            result = subprocess.run(['wat2wasm', output_file, '-o', wasm_output], 
                                                  capture_output=True, text=True)
                            if result.returncode != 0:
                                print(f"‚ùå Error compiling to WASM: {result.stderr}")
                                return False
                            print(f"‚úÖ Also generated -> {wasm_output}")
                    
                    return True
                except Exception as e:
                    print(f"‚ùå Compilation failed: {e}")
                    return False
            else:
                # Fallback to old WAT-based compilation
                print("‚ö†Ô∏è  Using legacy WAT-only compiler")
                if hasattr(compiler, 'compile_file'):
                    compiler.compile_file(str(roe_file), str(wat_file))
                else:
                    compiler.compile_roe_to_wat(roe_file, wat_file)
                
                if output_format == 'wasm':
                    # Compile to .wasm
                    result = subprocess.run(['wat2wasm', str(wat_file), '-o', str(wasm_file)], 
                                          capture_output=True, text=True)
                    if result.returncode != 0:
                        print(f"‚ùå Error compiling to WASM: {result.stderr}")
                        return False
                    print(f"‚úÖ Compiled successfully -> {wasm_file}")
                else:
                    print(f"‚úÖ Compiled successfully -> {wat_file}")
                
                return True
        except Exception as e:
            print(f"‚ùå Compilation failed: {e}")
            return False
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_compile()
                        print(f"üëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_compile()

def run_file(roe_filename, watch=False):
    """Compile and run a .droe file."""
    # Check if this is a mobile project first
    project_root = find_project_root()
    config = load_config(project_root)
    
    if config.get("target") == "mobile":
        # Use mobile-specific run function
        run_mobile_app(roe_filename, watch)
        return
    
    def do_run():
        # Read source to determine the actual target (respecting @target metadata)
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
            
        with open(roe_file, 'r') as f:
            source_content = f.read()
        
        # Use proper target resolution: @target metadata > config > bytecode default
        config_target = config.get("target", "bytecode")  # Default to bytecode for speed
        target = compiler.get_target_from_source(source_content, config_target)
        
        # First compile (pass None as target_override to let compile_file do target resolution)
        success = compile_file(roe_filename, output_format=None, target_override=None)
        if not success:
            return False
        
        # Then run based on target
        if target == "bytecode":
            return run_bytecode_file(roe_filename)
        else:
            return run_wasm_file(roe_filename)
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_run()
                        print(f"\nüëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_run()

def run_bytecode_file(roe_filename):
    """Run a bytecode file using the Rust VM."""
    project_root = find_project_root()
    config = load_config(project_root)
    tool_dir = Path.home() / ".droelang"
    vm_binary = tool_dir / "droevm"
    
    roe_file = Path(roe_filename)
    if not roe_file.is_absolute():
        roe_file = Path.cwd() / roe_filename
    
    # Calculate build path
    config_build_dir = project_root / config["build"]
    if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
        relative_path = roe_file.relative_to(project_root)
    else:
        relative_path = Path(roe_file.name)
    
    basename = roe_file.stem
    build_dir = config_build_dir
    if relative_path.parent != Path("."):
        build_dir = build_dir / relative_path.parent
    
    bytecode_file = build_dir / f"{basename}.droebc"
    
    if not vm_binary.exists():
        print(f"‚ùå Error: Roe VM not found at {vm_binary}")
        print("üí° You may need to build the VM: cargo build --release --manifest-path droevm/Cargo.toml")
        return False
    
    print(f"üöÄ Running {bytecode_file} with Roe VM")
    print("‚îÄ" * 40)
    
    result = subprocess.run([str(vm_binary), 'run', str(bytecode_file)])
    return result.returncode == 0

def run_wasm_file(roe_filename):
    """Run a WASM file using Node.js (legacy)."""
    project_root = find_project_root()
    config = load_config(project_root)
    tool_dir = Path.home() / ".droelang"
    runtime = tool_dir / "run.js"
    
    roe_file = Path(roe_filename)
    if not roe_file.is_absolute():
        roe_file = Path.cwd() / roe_filename
    
    # Calculate build path
    config_build_dir = project_root / config["build"]
    if roe_file.is_absolute() and roe_file.is_relative_to(project_root):
        relative_path = roe_file.relative_to(project_root)
    else:
        relative_path = Path(roe_file.name)
    
    basename = roe_file.stem
    build_dir = config_build_dir
    if relative_path.parent != Path("."):
        build_dir = build_dir / relative_path.parent
    
    wasm_file = build_dir / f"{basename}.wasm"
    
    print(f"üöÄ Running {wasm_file}")
    print("‚îÄ" * 40)
    
    result = subprocess.run(['node', str(runtime), str(wasm_file)])
    return result.returncode == 0


def build_mobile_project(project_root, clean=False, release=False):
    """Build mobile project - development or release."""
    try:
        # Import mobile build system
        sys.path.insert(0, str(Path.home() / ".droelang"))
        from compiler.targets.mobile.build_system import MobileBuildSystem
        
        if clean:
            clean_build(all_dirs=False)
        
        builder = MobileBuildSystem(Path(project_root))
        results = builder.build_mobile_projects(release=release)
        
        if results:
            if release:
                print(f"\nüéâ Release builds completed!")
                for platform, path in results.items():
                    print(f"   üì± {platform.title()}: {path}")
            else:
                print(f"\n‚úÖ Development builds completed!")
        else:
            print(f"\n‚ùå No builds were successful")
            print(f"üí° Check that mobile projects exist in build/ directory")
            exit(1)
            
    except ImportError as e:
        print(f"‚ùå Mobile build system not available: {e}")
        print(f"üí° Make sure the Droelang compiler is properly installed")
        exit(1)
    except Exception as e:
        print(f"‚ùå Mobile build failed: {e}")
        exit(1)


def run_mobile_app(roe_filename, watch=False):
    """Run mobile app with incremental updates."""
    def do_mobile_run():
        # First ensure projects are up to date
        success = compile_file(roe_filename, output_format=None, target_override=None)
        if not success:
            return False
        
        # Then run the mobile app
        try:
            sys.path.insert(0, str(Path.home() / ".droelang"))
            from compiler.targets.mobile.build_system import MobileBuildSystem
            
            project_root = find_project_root()
            builder = MobileBuildSystem(Path(project_root))
            return builder.run_mobile_app()
            
        except ImportError as e:
            print(f"‚ùå Mobile build system not available: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Failed to run mobile app: {e}")
            return False
    
    if watch:
        print(f"üëÄ Watching {roe_filename} for changes...")
        roe_file = Path(roe_filename)
        if not roe_file.is_absolute():
            roe_file = Path.cwd() / roe_filename
        
        last_modified = 0
        
        try:
            while True:
                if roe_file.exists():
                    current_modified = roe_file.stat().st_mtime
                    if current_modified > last_modified:
                        last_modified = current_modified
                        print(f"\nüìù Change detected at {datetime.now().strftime('%H:%M:%S')}")
                        do_mobile_run()
                        print(f"\nüëÄ Watching for changes...")
                
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è Watch mode stopped")
    else:
        do_mobile_run()


if __name__ == "__main__":
    main()

