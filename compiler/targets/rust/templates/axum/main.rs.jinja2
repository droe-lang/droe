use axum::{
    Router,
    routing::{get, post, put, delete},
    response::Json,
    extract::{Path, State},
};
use tower_http::cors::CorsLayer;
use std::net::SocketAddr;
use std::sync::Arc;

mod models;
mod handlers;
{% if has_database_ops %}
mod db;
use db::Database;
{% endif %}

#[derive(Clone)]
pub struct AppState {
{% if has_database_ops %}
    db: Arc<Database>,
{% endif %}
}

#[tokio::main]
async fn main() {
    // Initialize tracing
    tracing_subscriber::fmt::init();
    
{% if has_database_ops %}
    // Initialize database
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "{{ default_db_url }}".to_string());
    let db = Arc::new(Database::new(&database_url).await.expect("Failed to connect to database"));
    
{% endif %}
    // Build application state
    let state = AppState {
{% if has_database_ops %}
        db,
{% endif %}
    };
    
    // Build router
    let app = Router::new()
{% for endpoint in serve_endpoints %}
        .route("{{ endpoint.endpoint }}", {{ endpoint.method.lower() }}(handlers::{{ endpoint.handler_name }}))
{% endfor %}
        .layer(CorsLayer::permissive())
        .with_state(state);
    
    // Run server
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::info!("Server listening on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}