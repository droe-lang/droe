use sqlx::{{ '{' }}{{ db_type.capitalize() }}Pool, Pool, {{ db_type }}::{{ db_type.capitalize() }}{{ '}' }};
use crate::models::*;

pub struct Database {
    pool: Pool<{{ db_type.capitalize() }}>,
}

impl Database {
    pub async fn new(database_url: &str) -> Result<Self, sqlx::Error> {
        let pool = {{ db_type.capitalize() }}Pool::connect(database_url).await?;
        Ok(Self { pool })
    }
    
    pub fn pool(&self) -> &Pool<{{ db_type.capitalize() }}> {
        &self.pool
    }

{% for name, data_def in data_structures.items() %}
    pub async fn find_{{ name | snake_case }}_by_id(&self, id: &str) -> Result<Option<{{ name }}>, sqlx::Error> {
        let result = sqlx::query_as::<_, {{ name }}>(
            "SELECT * FROM {{ name | snake_case }}s WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(result)
    }
    
    pub async fn find_all_{{ name | snake_case }}s(&self) -> Result<Vec<{{ name }}>, sqlx::Error> {
        let results = sqlx::query_as::<_, {{ name }}>(
            "SELECT * FROM {{ name | snake_case }}s"
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(results)
    }
    
    pub async fn create_{{ name | snake_case }}(&self, data: {{ name }}) -> Result<{{ name }}, sqlx::Error> {
        // Implementation depends on specific fields
        todo!("Implement create")
    }
    
    pub async fn update_{{ name | snake_case }}(&self, id: &str, data: {{ name }}) -> Result<{{ name }}, sqlx::Error> {
        // Implementation depends on specific fields
        todo!("Implement update")
    }
    
    pub async fn delete_{{ name | snake_case }}(&self, id: &str) -> Result<(), sqlx::Error> {
        sqlx::query("DELETE FROM {{ name | snake_case }}s WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        
        Ok(())
    }
{% endfor %}
}